"""
Task Number: Task 4
File Path: src/05_portfolio_optimization.py
Created by: Addisu Taye
Date: August 12, 2025

Purpose:
This module applies Modern Portfolio Theory (MPT) to optimize a portfolio of three assets: Tesla (TSLA), Vanguard Total Bond Market ETF (BND), and S&P 500 ETF (SPY). It uses the forecasted return for TSLA generated by the LSTM model in Task 3, while using historical average returns for BND and SPY. The covariance matrix is computed from historical daily returns to model risk. The goal is to generate the Efficient Frontier, identify key portfolios (Maximum Sharpe and Minimum Volatility), and recommend an optimal asset allocation for GMF Investments.

Features:
- Loads historical price data and LSTM forecast.
- Computes expected returns:
    - TSLA: Forecasted annual return from LSTM.
    - BND & SPY: Historical mean returns (annualized).
- Computes sample covariance matrix from historical daily returns.
- Uses PyPortfolioOpt to generate the Efficient Frontier.
- Identifies and marks:
    - Maximum Sharpe Ratio Portfolio (Tangency Portfolio)
    - Minimum Volatility Portfolio
- Plots the Efficient Frontier with labeled optimal portfolios.
- Recommends a final portfolio with weights, expected return, volatility, and Sharpe ratio.
- Saves results for use in backtesting (Task 5).

Dependencies:
- pandas, numpy: Data handling.
- PyPortfolioOpt: For MPT optimization and plotting.
- matplotlib: For visualization.
- joblib: To load forecast and data.

Usage:
Run after completing Task 3.
    python src/05_portfolio_optimization.py

Output:
- Console: Optimal weights, portfolio metrics, and recommendation.
- Saved weights: models/optimal_weights.pkl
- Visualization: assets/figures/efficient_frontier.png
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pypfopt import EfficientFrontier, risk_models, expected_returns
from pypfopt import plotting
import joblib
import os

# Create output directories
os.makedirs("models", exist_ok=True)
os.makedirs("assets/figures", exist_ok=True)

# ========================
# 1. Load Data
# ========================
try:
    df = pd.read_pickle("data/raw/stock_data.pkl")
    print("‚úÖ Data loaded from data/raw/stock_data.pkl")
except FileNotFoundError:
    raise FileNotFoundError("‚ùå File not found: data/raw/stock_data.pkl")

try:
    future_forecast = joblib.load("models/future_forecast.pkl")
    print("‚úÖ LSTM forecast loaded from models/future_forecast.pkl")
except FileNotFoundError:
    raise FileNotFoundError("‚ùå File not found: models/future_forecast.pkl")

# Calculate daily returns
returns = df.pct_change().dropna()

# ========================
# 2. Expected Returns
# ========================
# Use historical mean return (annualized) for BND and SPY
mu_historical = expected_returns.mean_historical_return(df)

# Replace TSLA return with forecasted annual return
forecast_daily_returns = future_forecast.pct_change().dropna()
forecasted_annual_return_tsla = forecast_daily_returns.mean() * 252
mu_historical["TSLA"] = forecasted_annual_return_tsla

print(f"üìä Expected Annual Returns:")
for asset, ret in mu_historical.items():
    print(f"   {asset}: {ret:.2%}")

# ========================
# 3. Covariance Matrix
# ========================
# Use sample covariance of historical returns
S = risk_models.sample_cov(df)

# ========================
# 4. Optimize Portfolio
# ========================
ef = EfficientFrontier(mu_historical, S)

# Max Sharpe Ratio Portfolio (Tangency Portfolio)
sharpe_portfolio = ef.deepcopy()
weights_sharpe = sharpe_portfolio.max_sharpe(risk_free_rate=0.03)
ret_sharpe, vol_sharpe, sharpe_ratio = sharpe_portfolio.portfolio_performance(risk_free_rate=0.03)

# Min Volatility Portfolio
minvol_portfolio = ef.deepcopy()
weights_minvol = minvol_portfolio.min_volatility()
ret_min, vol_min, _ = minvol_portfolio.portfolio_performance(risk_free_rate=0.03)

# ========================
# 5. Plot Efficient Frontier
# ========================
fig, ax = plt.subplots(figsize=(12, 7))
plotting.plot_efficient_frontier(ef, ax=ax, show_assets=True, alpha=0.6)

# Plot optimal portfolios
ax.scatter(vol_sharpe, ret_sharpe, marker="*", s=200, c="r", label="Max Sharpe Portfolio", edgecolors="black", linewidth=1)
ax.scatter(vol_min, ret_min, marker="*", s=200, c="g", label="Min Volatility Portfolio", edgecolors="black", linewidth=1)

# Labels and formatting
ax.set_title("Efficient Frontier with Optimal Portfolios", fontsize=16, fontweight='bold')
ax.set_xlabel("Annual Volatility (Risk)", fontsize=12)
ax.set_ylabel("Expected Annual Return", fontsize=12)
ax.legend(fontsize=11)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig("assets/figures/efficient_frontier.png", dpi=150)
plt.close()
print("üìä Efficient Frontier saved to assets/figures/efficient_frontier.png")

# ========================
# 6. Final Recommendation
# ========================
print("\n" + "="*60)
print("           OPTIMAL PORTFOLIO RECOMMENDATION")
print("="*60)

print("üîπ Maximum Sharpe Portfolio (Risk-Adjusted Return):")
for asset, weight in weights_sharpe.items():
    print(f"   {asset}: {weight:.2%}")
print(f"   Expected Return: {ret_sharpe:.2%}")
print(f"   Annual Volatility: {vol_sharpe:.2%}")
print(f"   Sharpe Ratio (rf=3%): {sharpe_ratio:.3f}")

print("\nüî∏ Minimum Volatility Portfolio (Lowest Risk):")
for asset, weight in weights_minvol.items():
    print(f"   {asset}: {weight:.2%}")
print(f"   Expected Return: {ret_min:.2%}")
print(f"   Annual Volatility: {vol_min:.2%}")

# Recommend Max Sharpe (balanced growth & risk)
recommended_weights = weights_sharpe
recommended_return = ret_sharpe
recommended_vol = vol_sharpe
recommended_sr = sharpe_ratio

print("\n" + "‚úÖ" + "="*59)
print("           RECOMMENDED PORTFOLIO")
print("‚úÖ" + "="*59)
print("We recommend the **Maximum Sharpe Ratio Portfolio** because it offers the best risk-adjusted return, aligning with GMF's goal of optimizing performance while managing risk.")
print("\nOptimal Weights:")
for asset, weight in recommended_weights.items():
    print(f"   {asset}: {weight:.2%}")
print(f"\nExpected Annual Return: {recommended_return:.2%}")
print(f"Annual Volatility: {recommended_vol:.2%}")
print(f"Sharpe Ratio (rf=3%): {recommended_sr:.3f}")

# Save recommended weights
joblib.dump(dict(recommended_weights), "models/optimal_weights.pkl")
print("\nüíæ Optimal portfolio weights saved to models/optimal_weights.pkl")

